CSE 307 – Principles of Programming Languages
Fall, 2025
Homework Assignment 03
Building a Programming Language: Expressions
Assigned: 09/29/2025
Due: Monday, 10/20/2025, at 11:59 PM
Total Points: 50
Over the course of the next three programming assignments (HW03,
04, and 05) we will be implementing a programming language. We
will call this language, SBML.
For this assignment we will be constructing an expression
evaluator. The evaluator will take an expression as input,
evaluate the expression, and then print the result to standard
output.
Your program must construct an abstract syntax tree representing
the input expression during parsing.
Semantic analysis and expression evaluation will then be done
through recursive operation on the contents of the syntax tree
starting at the root. This will be discussed with examples in
class. Doing so will make the next stage of this assignment more
manageable.
The code written for this assignment will be reused in future
assignments. Please keep that in mind when working. Keep your
code clean, neat, and modular so that it will be easy to update
and extend in future assignments.
We will use the parser generator PLY – Python Lex and Yacc – to
specify and implement the SBML language.
Installation Instructions for PLY:
1. Using PIP:
> pip3 install ply –-user
or
> python3 -m pip install ply –-user
2. Manual Installation Using setuptools
-Download the ply archive; https://www.dabeaz.com/ply/
-Unzip the archive.
-From command-line, navigate to the ply directory.
-Run the command: python3 setup.py install –-user
SBML description:
SBML Datatypes:
• Numbers:
o Integers and Reals – implement as Python integers
and floats.
• Booleans:
o True and False – implement as Python Booleans.
• Strings:
o Sequences of characters enclosed within matching
single or double quotes in a single line. Strings
should be implemented using the equivalent Python
String type.
• List:
o Finite, ordered sequence of elements separated by
commas and enclosed within matching square brackets.
Elements of the list need not be of the same type.
Implement as Python list.
• Tuple:
o Finite, ordered sequence of elements separated by
commas and enclosed within matching parentheses.
Elements of the tuple need not be of the same type.
SBML Literal Representation of Data Types:
• Integer:
o Positive (no sign) or negative (unary -) whole
numbers in base-10 representation (decimal
representation).
o An integer literal is one or more digits, 0-9.
 Examples: 57, -18, 235
• Real:
o A real value is represented by 0 or more digits (0-
9), followed by a decimal point, ".", followed by 0
or more digits (0-9), except that a decimal point by
itself with no leading or trailing digit is not a
real.
 Examples: 3.14159, 0.7, .892, 32787.
o A real can also contain exponents as in scientific
notation. In this case, a real value, as defined
above, is followed by an "e" character and then a
positive or negative integer, as defined above.
 Examples: 6.02e-23, 17.0e4
• Boolean:
o True, False (just as in Python)
• String:
o A string literal begins with a single or double
quote, followed by zero or more non-quote
characters, and ends with a matching quote.
o The value of the string literal does not include the
starting and ending quotes.
 Examples: "Hello World!", "867-5309"
• List:
o A list literal is composed by a left square bracket,
followed by a comma-separated sequence of zero or
more expressions, followed by a right square
bracket.
 Examples:
• ["a", "b"]
• [1, 2]
• [307, "307", 304+3]
SBML Operators:
Operator precedence and associativity is given below.
01. ( expression ) – A parenthesized expression
02. ( expression1, expression2, … ) – Tuple constructor
• A singleton tuple can be constructed by including a
comma after the expression.
• Example ( expression1, )
• There are no empty tuples
03. #i(tuple) – returns the argument at index i in the
tuple. Indices start at 1 as in SML.
04. a[b] – Indexing Operation. b can be any expression.
05. a ** b – Exponentiation. base a raised to the power b.
right associative: 2**3**4 == 2**(3**4)
06. a * b – Multiplication. Overloaded for integers and
reals.
07. a / b – Division. Overloaded for integers and reals,
but result is always a real value.
08. a div b – Integer Division. Returns just the quotient.
a and b are integers.
09. a mod b – Modulus. Divides a by b and returns just the
remainder. a and b are integers.
10. a + b – Addition. Overloaded for integers, reals,
strings, and lists.
11. a – b – Subtraction. Overloaded for integers and reals.
12. a in b – Membership. Evaluates to True if it finds the
value of a inside the string or list
represented by b.
13. a::b – Cons. Adds operand a to the front of the list
referred to by operand b.
14. not a – Boolean negation.
15. a andalso b – Boolean Conjunction (AND)
16. a orelse b – Boolean Disjunction (OR)
17. a < b – Less than. Comparison.
18. a <= b – Less than or equal to. Comparison.
19. a == b – Equal to. Comparison.
20. a <> b – Not equal to. Comparison.
21. a >= b – Greater than or equal to. Comparison.
22. a > b – Greater than. Comparison.
SBML Operator Precedence:
Operator Precedence for SBML (ordered from lowest to highest):
All operators are left-associative, except for exponentiation
(**) and cons (::), which are right-associative
Operators on the same line have the same precedence.
01. orelse Boolean Disjunction
02. andalso Boolean Conjunction
03. not Boolean Negation
04. <, <=, ==, <>, >=, > Comparison Operators (for
numbers and strings)
05. h::t Cons operator
06. in Membership test
07. +, - Addition and Subtraction
(Overloaded for numbers,
strings, lists)
08. *, /, div, mod Multiplication, Division,
Integer Division, Modulus
09. ** Exponentiation
10. a[b] Indexing
11. #i(tuple) Tuple Indexing
12. (exp1, exp2,...) Tuple Creation
13. (exp) Parenthetical Expression
SBML Operator Semantics:
• Indexing:
o Operand a must be either a string or a list. Operand
b must be an integer.
o If a is a string, then return the b-th character as
a string.
o If a is a list, then return the b-th element as an
instance of whatever type it is.
o The index is 0-based.
o If the index is out of bounds, then this is a
semantic error.
• Addition:
o Operands must either both be numbers, or both be
strings, or both be lists.
o If they are integers or reals, then addition with
standard (Python) semantics is performed.
o If a and b are both strings, then string
concatenation is performed.
o If a and b are both lists, then list concatenation
is performed.
• Subtraction:
o Operands must both be integers or reals.
o Performed using standard subtraction semantics.
• Multiplication:
o Operands must both be integers or reals.
o Performed using standard multiplication semantics.
• Division:
o Operands must both be integers or reals.
o Operand b cannot be 0.
o Performed using standard division semantics.
• Booleans:
o Operands for Boolean operations (not, andalso,
orelse) must be Boolean values.
• Comparisons:
o Operands must either both be numbers or both be
strings.
o Comparison of numbers (integers and strings) should
follow standard semantics.
o Comparison of strings should follow the Python
semantics.
o Returns True if comparison is true, and False if
comparison is False.
Program Organization:
Your program must be implemented using the following three
files.
• sbml_ast.py:
o This file will contain the implementation of your AST
node classes.
o Each node should have an evaluate() method and a
__str__() method defined.
• sbml_parser.py:
o This file will contain the implementation of your PLY
grammar for the SBML language.
o This should include:
 Token definitions for the lexer
 Production function definitions for the parser.
 Implementation of action routines (semantic
rules) in each production function to construct
AST nodes and assemble them into a tree.
• sbml_main.py:
o This file will be the driver for your expression
evaluator.
o It should do the following:
 It will read a file name as command-line input
 pass the file content to the lexer-parser
constructed by PLY according to the grammar
defined in sbml_parser.py
 get back the root of the Abstract Syntax Tree
constructed by the parser
 then call either print() and pass in the root
node of the AST or invoke evaluate() on the root
AST node to produce either a display of the AST
or the result of evaluating the expression.
Program Behavior:
Print Operation:
-The program will be called with two command-line
arguments. The first will be -P (for print). The second
will be the name of an input file.
Like So: python3 sbml_main.py -P <input_file_name.txt>
-Your program should process each expression in the input
file, one at a time--there will be one expression per line
of the input file.
-As output, your program should print to STDOUT, each node
in the AST. For each node the node type and the values of
its non-node attributes should be present and labelled
clearly.
-The order in which the nodes are printed does not matter.
A pre-order traversal will ensure that parents appear
before children, post-order will do the opposite.
-Don't spend too much time trying to fine tune this. I just
want to be able to see some representation of the syntax
tree being built by your program.
Normal Operation:
-Your program will be called with two command-line
arguments. The first will be -E (for evaluate). The second
argument will be the name of an input file. As above, the
input file will contain a sequence of SBML expressions,
one per line.
Like So: python3 sbml_main.py -E <input_file_name.txt>
-Your program should process each expression one-by-one,
And produce one of the following three outputs, printed to
STDOUT:
1. If the line contains a syntax error, then print:
"SYNTAX ERROR".
2. If the line contains a semantic error, then print:
"SEMANTIC ERROR".
3. Otherwise, evaluate the expression and print the
result (note that string outputs should be enclosed in
single quotes, as the Python interpreter does).
Example:
Input File:
1 - 2 + 3
1 2
42 + "Red"
1 - (2 + 3)
"Hello" + " " + "SBML."
[[1], 2, 3][0][0] + 40
Output:
2
SYNTAX ERROR
SEMANTIC ERROR
-4
'Hello SBML.'
41
Submission Instructions:
1. Please include your name and student id as comments at the
top of your program files (All of them).
2. Please collect and submit your program file as a compressed
zip file.
3. The title of the compressed file should be:
cse307_hw03_LastNameFirstName.zip
4. Points will be lost if filenames do not match the ones
given in the instructions.
5. This is an individual assignment. Any collaboration on
writing your programs will be treated as a violation of
academic integrity.